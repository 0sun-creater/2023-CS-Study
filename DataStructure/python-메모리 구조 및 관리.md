

-------
-------  
### 메모리 구조
- 스택(stack) 영역 : 지역변수/ 매개변수 저장, 함수가 호출될 때 할당되고 호출이 끝나면 소멸  
- 힙(heap) 영역 : new 명령으로 생성된 인스턴스 변수(사용자의 동적할당)가 저장, 메소드 호출이 끝나도 소멸되지 않음  
- 데이터(data) 영역 : 전역변수/정적변수 저장, 프로그램이 시작될 때 할당되고 프로그램이 종료되면 소멸  
- 코드(text) 영역: 실행할 프로그램의 코드 저장
![image](https://github.com/songhee-lee/2023-CS-Study/assets/54173210/17faa1c4-dfb0-47a6-bf6f-e0428bd2f4ba)

- 내부적으로 자동으로 메모리를 관리해주는 python memory manger 존재  
- 모든 객체와 데이터 구조를 private heap 영역에 저장
- 스택영역에는 참조자를 저장하고, 힙 영역에는 객체 저장  
- python memory manger는 힙 메모리에 있는 객체를 참조하는 형태로 동적할당을 자동으로 해줌  
- interpreter가 포인터를 사용하여 힙 메모리 영역의 범위를 조정, 메모리가 필요할때마다 OS와 소통하면서 할당  
![image](https://github.com/songhee-lee/2023-CS-Study/assets/54173210/71234c88-bcf5-4aef-915a-338b71f02cf9)

### 메모리 관리
- python private heap space에서 관리됨 (숨겨진 힙 스페이스)
- 모든 객체와 자료구조 저장  
- 인터프리터가 스페이스를 관리 -> 프로그래머 또한 이 공간에 접근 불가능  
- 내장된 garbage collector가 있어서 사용되지 않는 메모리 재사용 가능  


GC 작동 방식
- 파이썬은 객체를 레퍼런스 카운트를 통해 관리
- 객체를 참조하는 횟수가 늘어날수록 해당 객체의 레퍼런스 카운트는 증가, 참조 횟수가 줄어들수록 감소 
- 레퍼런스 카운트가 0이 되면 객체는 메모리에서 해제
- 단, 레퍼런스 카운트가 0이 아닌 경우에도 자가 참조 혹은 삭제된 객체들이 순환 참조되어 도달할 수 없는 경우에도 메모리에서 해제

- 가비지 컬렉터는 세대와 임계값을 통해 가비지 컬렉션의 주기 관리

- 새로운 객체가 만들어 질 때 파이썬은 _PyObject_GC_Alloc() 호출
- 객체를 메모리에 할당하고 가비지 컬렉션을 진행한다.

Python 나갈 때 왜 모든 memory가 할당 해제되지 않는지?
- C에서 예약된 메모리 할당 해제는 불가능

Shallow / Deep copy
- Shallow copy : 새로운 instance가 생성될 때 사용
- Deep copy : 이미 복사된 값 저장할 때 사용
